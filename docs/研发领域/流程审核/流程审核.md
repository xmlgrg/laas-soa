# 单个流程

流程在使用形式上分成流程结构(流程模板)和流程数据(流程实例)

流程模板的查询、新增、修改、删除

流程实例的查询编排、查询、查询日志、创建、流动、回滚、驳回、销毁

流程模板的数据结构(workflow_struct): (查询编排时查询执行service_type中版本最大的)

```
{
	"id": 1, 					// 自增主键, 同时作为版本号
	
	"service_type": "deploy"， 	// 业务类型
	"workflow": "dev>test" 		// 流程中的角色的审核顺序
	
    // 修改记录
	"create_by": "", 			// 创建人
	"create_datetime": "", 		// 创建时间 CURRENT_TIMESTAMP
}
```

流程实例的数据结构(workflow_data):

```
{
	"id": 1, // 自增主键
	
	// 流程数据
	"title": "test", 			// 标题
	"service_type": "deploy", 	// 业务类型
	"form_data_id": "", 		// 表单数据id
	"form_data": "", 			// 表单数据
	
	// 流程
	"steps": "", 				// 整体审核人流程
    "next_steps": "", 			// 剩余审核人流程
    "next_step": "", 			// 下一个审核人
    
    // 流程组
    "group_id": "", 			// 流程组的id
    "execute_order": "", 		// 执行顺序
	
	// 状态
	"status": "", 				// 流程状态
	"service_status": "", 		// 业务执行状态
	
	// 修改记录
	"create_by": "", 			// 创建人
	"create_datetime": "", 		// 创建时间 CURRENT_TIMESTAMP
}
```

流程实例记录的数据结构(workflow_data_record):

```
{
	"id": 1, 					// 自增主键
	
	"workflow_id": "1", 		// 流程id
	
	"status": "", 				// 状态
	"create_by": "", 			// 创建人 这里也当做审核人记录使用, 可以推断出某个流程经历哪些人做什么审核动作
	"create_datetime": "", 		// 创建时间 CURRENT_TIMESTAMP
}
```



流程业务日志的数据结构(workflow_business_log):

```
{
	"id": 1, 					// 自增主键
	
	"workflow_id": "1", 		// 流程id
	
	"content": "", 				// 内容
	
	"create_datetime": "", 		// 创建时间 CURRENT_TIMESTAMP
}
```

流程业务回滚的数据结构(workflow_business_rollback):

```
{
	"id": 1, 					// 自增主键
	
	"workflow_id": "1", 		// 流程id
	
	"content": "", 				// 内容
	
	"create_datetime": "", 		// 创建时间 CURRENT_TIMESTAMP
}
```

流程状态 为:

```
流转中、已回滚、已驳回、已销毁
```

流转动作 为:

```
流转、回滚、驳回、销毁
```

流程组的动作 为:

```
合并、拆分
```



# 其他问题

单个流程, 一般都是按照流程的角色的用户列表顺序审核, 在审核完成之后执行业务

但是多个流程不一样了

如果是依次按照单个流程的顺序进行串行审核, 则会出现业务进行缓慢, 有重大风险

如果按照多个流程的顺序进行合并审核, 则会在一定概率上降低了流程发挥的审核意义




解决思路

针对单个业务, 并行审核, 在单个流程的全部审核环节的末端进行强行阻断, 等待全部流程审核完成之后再一起执行

针对多个业务, 串行审核, 审核完成之后立刻执行, 不等待后续其他业务流程, 分散执行压力, 提高执行效率


针对有依赖关系的工单, 标记顺序, 执行时按照顺序进行执行



为了确保正确运作, 执行都是串行的

审核都是并行的, 但是一个流程组内的执行是按照顺序依次执行





单个流程时问题不大, 但是多个流程时就有问题了

流程组:

并行, 审核时并行, 执行时按照顺序串行执行, 应用于单个项目场景





用专门的配置记录 研发变更流程中自动执行的顺序, database>schedule>config>deploy

从依赖顺序角度看, 依赖链上游的先执行, 所以部署最后执行

先从执行时间角度看, 执行顺序长的先执行, 所以先执行数据库

计划任务和配置先后都可以

同时支持自定义执行顺序



后续需要对接xxljob, 以及重写配置中心







# 流程组

这样一反推就发现, 其他的流程引擎貌似是不支持搜索子流程的



流程和流程组在结构上是一致的, 区别在于流程组由系统创建, 填充空值, 作为逻辑上的外键约束, 应用于流程标记以及约束最终执行时机

每一个流程都有一个流程组, 默认为空

​	界面上的合并操作同时只能选择一个流程组和至少一个流程

​		合并流程到流程组时, 设置流程的流程组为流程组流程的id



界面列表默认查询流程组为空的流程(包含流程组)

​	通过异步查询流程的流程组为该流程组的id查询出子流程列表, 并显示在流程组下行拓展框内



如何搜索子流程?

​	不把子流程的信息归并到流程组中

​	不管搜索之后如何归并, 按照上面正常的流程使用, 子流程不展示, 依旧跟随流程组

​	查询SQL中判断是流程组时, (通过判断有否有流程以自己的id作为流程组判断自己是否为流程组)

```
exists (select 1 form workflow_data where group_id = wfd.id)
```

​		则SQL查询条件为查询子流程的数据

```
exists (select 1 form workflow_data where group_id = wfd.id and <子流程的查询条件...>)
```

​	

如果是使用flowable这种静态流程, 那么需要提前定义好各个子流程, 在使用时通过启用开关去启用, 这样配置的静态流程都很复杂

基于上面这种流程组(动态)就不再需要提前定义静态流程了

# 融合整体并落地

数据直接存在cmdb中即可